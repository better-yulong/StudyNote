并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的要本原因。
#### 一、概述
衡量一个服务性能的高低好坏，每秒事务数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均响应的请求总数。

#### 二、硬件的效率与一致性
1. CPU优化技术：CPU高速缓存、指令乱序执行
处理器性能 = 主频 X IPC（每周期执行的指令数），提升ICP的做法有两种：提高单核并行的度或者多核
- 高速缓存（Cache）是处理器与内存之间的缓冲。每个处理器都有自己的高速缓存，而它们又共享同一主内存，即引入新的问题：缓存一致性（Cache Coherence）。当多个处理哭器的运算任务都涉及同一主内存时，可能导致缓存数据不一致，为解决该问题，需各处理器访问高速缓存时遵循一些协议，读写必须根据协议来操作。而"内存模型"则可理解为特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。
> ![处理器、高速缓存、主存之间的交互关系](https://github.com/better-yulong/StudyNote-Resource/blob/master/StudyNote-Resource/12-001.PNG)
- 除增加高速缓存外，处理器内部也可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，仅保证同一处理结果与顺序执行一致，但若一个计算任务依赖中外一个计算任务的中间结果，则顺序性并不能靠代码先后顺序来保障（多线程明显，即不能单纯的代码顺序等价于执行顺序）。
与此类似，Java虚拟机的即时编译器也有类似的指令重排序（Instruction Reorder）优化。

#### 三、Java内存模型
Java虚拟机规范定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异 ，以实现Java程序在各平台能达到一致的内存访问效果。而此之前，主流语言（如C/C++）等则直接使用物理硬件和操作系统的内存模型，因为会由于不同内存模型平台的差异，导致程序在不同的平台执行异常，使得需针对不同平台编写程序。
而Java内存模型必须足够严谨以避免Java的内存并发访问操作产生歧义；但也需足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件各种特性（寄存器、高速缓存和指令集中某些特有指令）来获取更好的执行速度。直到JDK1.5，Java内存模型对相对完善和成熟。
##### 1. 主内存与工作内存
- Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机将变量存储到内存和从内存读取变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数（因局部变量与方法参数为线程私有，不会被共享也不存在竞争）。这了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内交互，也没有限制即时编译器进行代码执行顺序高速这类优化措施。
- Java内存模型规定所有的变量都存储在主内存（Main Memory，其是虚拟机内存的一部分但类似硬件的主内存）。每条线程还有各自的工作内存（Working Memory,其是虚拟机内存的一部分但类似硬件的处理器高速缓存），线程的工作内存保存了该线程使用到的变量的主内存副本拷贝（注意：局部就是表是一个reference类型时，它引用的对象在Java堆中是可被各线程共享的，但是reference本身在Java的局部变量表，是线程私有的）。线程对变量的所有操作（读取、赋值等）都必须在工作内存进行，而不能直接读写主内存中的变量。不同线程无法直接访问对方工作内存内的变量，线程间变量值的传递均需通过主内存完成，线程、主内存、工作内存三者关系如图：
![JMM内存模型交互](https://github.com/better-yulong/StudyNote-Resource/blob/master/StudyNote-Resource/12-002.PNG)
> 此处的主内存、工作内存与第2章Java内存区域的Java堆、栈、方法区等并非同一层次的内存划分，基本没有关系。对于JMM和JVM本身的内存模型，这两者本身没有关系。如果一定要勉强对应，则从变量，主内存，工作内存的定义来看，主内存主要是对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就是物理内存，而为了获取更好的执行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为运行时主要访问–读写的是工作内存。
- JMM的目的是为了解决Java多线程对共享数据的读写一致性问题，通过Happens-Before语义定义了Java程序对数据的访问规则，修正之前由于读写冲突导致的Cache数据不一致的问题。具体到Hotspot VM的实现，主要是由OrderAccess类定义的一些列的读写屏障来实现JMM的语义；即是线程与内存之间的逻辑内存模型。
- JVM内存模型则是指JVM的内存分区，是JVM运行时数据区的内存划分的逻辑内存模型。
- 归根结底，JMM内存模型及JVM运行时数据区均是Java虚拟机规范定义的规则，仅是逻辑概念。
1. 拷贝副本：对象引用、对象中某个线程访问一的字段有可能拷贝，但虚拟机不会实现整个对象拷贝。
2. 根据Java虚拟机规范，volatitle变更依然有工作内存的拷贝，但由于它特殊的操作顺序性规定，只是其看起来如同直接在主内存读写访问。

##### 2. 内存间交互工作
主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存的实现细节，Java内存模型定义了以下8种操作，虚拟机需保证下面提及的第一项都必须是原子、不可再分（double、long类型变量部分平台可能有例外）：
- lock（锁定）:作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）:作用于主内存，把一个处于锁定


