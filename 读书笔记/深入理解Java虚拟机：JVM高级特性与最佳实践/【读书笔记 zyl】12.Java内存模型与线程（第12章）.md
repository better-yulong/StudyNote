并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的要本原因。
#### 一、概述
衡量一个服务性能的高低好坏，每秒事务数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均响应的请求总数。

#### 二、硬件的效率与一致性
1. CPU优化技术：CPU高速缓存、指令乱序执行
处理器性能 = 主频 X IPC（每周期执行的指令数），提升ICP的做法有两种：提高单核并行的度或者多核
- 高速缓存（Cache）是处理器与内存之间的缓冲。每个处理器都有自己的高速缓存，而它们又共享同一主内存，即引入新的问题：缓存一致性（Cache Coherence）。当多个处理哭器的运算任务都涉及同一主内存时，可能导致缓存数据不一致，为解决该问题，需各处理器访问高速缓存时遵循一些协议，读写必须根据协议来操作。而"内存模型"则可理解为特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。
> ![处理器、高速缓存、主存之间的交互关系](https://github.com/better-yulong/StudyNote-Resource/blob/master/StudyNote-Resource/12-001.PNG)
- 除增加高速缓存外，处理器内部也可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，仅保证同一处理结果与顺序执行一致，但若一个计算任务依赖中外一个计算任务的中间结果，则顺序性并不能靠代码先后顺序来保障（多线程明显，即不能单纯的代码顺序等价于执行顺序）。
与此类似，Java虚拟机的即时编译器也有类似的指令重排序（Instruction Reorder）优化。

#### 三、Java内存模型
Java虚拟机规范定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异 ，以实现Java程序在各平台能达到一致的内存访问效果。而此之前，主流语言（如C/C++）等则直接使用物理硬件和操作系统的内存模型，因为会由于不同内存模型平台的差异，导致程序在不同的平台执行异常，使得需针对不同平台编写程序。
而Java内存模型必须足够严谨以避免Java的内存并发访问操作产生歧义；但也需足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件各种特性（寄存器、高速缓存和指令集中某些特有指令）来获取更好的执行速度。直到JDK1.5，Java内存模型对相对完善和成熟。
##### 1. 主内存与工作内存
- Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机将变量存储到内存和从内存读取变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数（因局部变量与方法参数为线程私有，不会被共享也不存在竞争）。这了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内交互，也没有限制即时编译器进行代码执行顺序高速这类优化措施。
- Java内存模型规定所有的变量都存储在主内存（Main Memory，其是虚拟机内存的一部分但类似硬件的主内存）。每条线程还有各自的工作内存（Working Memory,其是虚拟机内存的一部分但类似硬件的处理器高速缓存），线程的工作内存保存了该线程
