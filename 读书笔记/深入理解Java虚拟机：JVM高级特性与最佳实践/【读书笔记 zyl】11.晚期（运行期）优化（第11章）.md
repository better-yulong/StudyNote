
#### 一、概述
> Java程序最初是通过解释器（Interpreter）解释执行，当虚拟机发现某方法或代码运行特别频繁，会把该部分代码认定为”热点代码“(Hot Spot Code）。为提供热点代码执行，运行时虚拟机会将这些代码编译成本地平台相关的机器码并进行各种上层次的优化，完成该任务的编译器称为即时编译器（Just In Time Compiler），简称不JIT编译器。
> 即时编译器非Java虚拟机规范所要求必须存在，更没有要求如何实现。但即时编译器性能好坏、代码优化程度则是衡量虚拟机优秀与否最关键的指标，它也是虚拟机最核心且最能体现技术水平的部分。

#### 二、HotSpot虚拟机内的限时编译器
带着如下问题去了解限时编译器的动作过程：
- 为何HotSpot虚拟机要使用解释器与编译器并存的架构？
- 为何HotSpot虚拟机要实现两个不同的即时编译器？
- 程序何是使用解释器执行？何时使用编译器执行？
- 哪些程序代码会被编译为本地代码？如何编译为本地代码？
- 如何从外部观察即时编译器的编译过程和编译结果？
##### 1、解释器和编译器
- 并非所有Java虚拟机都采用解释器和编译器并存架构，但主流商用虚拟机如HotSpot、J9等均同理包含解释器和编译器（JRockit面向服务端，其无解释器使得启动响应时间长）。解释器和编译器各有优势：程序需迅速启动和执行，则解释器可节省编译时间立即执行；运行期，编译器将热点代码编译成本地代码可获得更高的执行效率但内存资源消耗则会同步增加。另解释器与编译器涉及到激进优化相关需配合工作。
- HotSpot虚拟机内置两个限时编译器，分别称为Client Compiler和 Server Compiler，即简称为C1编译器和C2编译器（也叫Opto编译器）。主流HotSpot虚拟机默认采用解释器与其中一种编译器配合工作。程序使用的编译器取决于虚拟机运行模式，HotSpot虚拟机会根据自身版本及宿主机器的硬件性能自动选择，或者用户也可使用 "-client" 或 "-server" 参数强制指定运行在Client模式或者Server模式。
- 解释器和编译器搭配使用的方式在虚拟机中称为"混合模式"(Mixed Mode),用户可使用参数"-Xint"强制虚拟机运行于"解释模式"（Interpreted Mode），此模式编译器不工作，全部代码都使用解释方式执行。另外，也可使用参数"-Xcomp"强制虚拟机运行于编译模式（Compiled Mode),该模式优化采用编译方式运行，但若编译方式无法进行则解释器需介入执行。
```
	D:\>java -version
	java version "1.8.0_112"
	Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
	Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, ++mixed mode++)

	D:\>java -Xint -version
	java version "1.8.0_112"
	Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
	Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, ++interpreted mode++)

	D:\>java -Xcomp -version
	java version "1.8.0_112"
	Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
	Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, ++compiled mode++)
```
即时编译器编译本地代码需占用程序运行时间，且依赖解释器收集性能监控信息以便编译出优化程序更高的代码。为在程序启动响应速度与运行效率之间达到平衡，HotSpot虚拟机采用逐渐启用分层编译（Tiered Compilation)策略，其在JDK 1.7的Server模式首次作为默认编译器被开启。分层编译可划分为3个层次：
1. 第0层：程序解释执行，解释器不开启性能监控功能（Profiling),可触发第1层编译。
2. 第1层：也称为C1编译，将字节码编译为本地代码，进行简单、可靠优化；若有必要将加入性能监控逻辑。
3. 第2层：也称为C2编译，将字节码编译为本地代码，但会启用一些编译耗时较长的优化，甚至会根据监控信息进行不可靠的激进优化。

##### 2、编译对象与触发条件
> 热点代码：
1. 被多次调用的方法：方法调用多，方法体内执行次数多。由方法调用触发编译，因此整个方法作为编译对象，这种编译为虚拟机标准的JIT编译方式。
2. 被多次执行的循环体：方法调用较少，但方法内部循环体执行次数多。由循环体触发编译，但依然以整个方法（而不是单独的循环体）作为编译对象，这种编译发生于方法执行过程，故形象地称之为栈上替换（On Stack Replacement,简称OSR编译）
> 判断代码是否为热点代码及是否需触发即时编译，该行为称之为热点探测（Hot Spot Detection)，目前主要的热点探测判定方法有两种：
- 基于采样的热点探测（Sample Based Hot Spot Detection):采用这种方法的虚拟机会周期性检查各线程的栈顶，如果发现某（或某些）方法经常出现在栈顶，则认为该方法为"热点方法"。基于采样的热点探测好处是实现简单、高效，且可很容易获取方法调用关系（将调用堆栈展开即可）；缺点则是很难精确的确认一个方法的热度，容易受到线程阻塞或其他外界因素的影响而扰乱热点探测。
- 基于启动项器的热点探测（Counter Based Hot Spot Detection):采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数。若执行次数超过一定的阈值即认为该方法为"热点方法"。这种统计方式实现成本高，需要为每个方法建立并维护计数器，且不能直接获取方法的调用关系；但是其统计相对来说更精确和严谨。
> HotSpot虚拟机采用基于计数器的热点探测方法，因此它为每个类准备了两个计数器：方法调用计数器（Invocation Counter)和回边计数器(Back Edge Counter)。两个计数器共同拥有一个确定的阈值，当计数器超过该阈值，就会触发JIT编译。默认阈值在Client模式是1500次，Server模式是10000次，阈值可通过虚拟机参数-XX:CompileThreshold 来设置。









参考资料：[JIT晚期(运行期)](https://www.cnblogs.com/wade-luffy/p/6050483.html)