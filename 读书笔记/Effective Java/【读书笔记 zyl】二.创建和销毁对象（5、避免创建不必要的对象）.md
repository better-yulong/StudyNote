一般来说，最好能重用对象而不是每次需要时都创建一个相同功能的新对象。重用方式即快速，又流行。若对象是不可变的（immutable），则其始终可被重用。
```language
	//反面示例
	String s = new String("string temp"); //DON'T DO THIS
```
该语句会使得每次执行时都创建一个新的String实例，但是这些创建动作全都是不必要。传递给String构造器的参数（"string temp"）本身就是一个String实例，功能方面等同于构造器所创建的所有对象。如果这种方法在一个循环或者是在一个被频繁调用的方法中，就会创建出成千上万不必要的String实例，可考虑改进为：
```language
	String s = "string temp" ; //改进版本，基于字面量、字符串常量池。String.intern()也可避免多次创建新String对象，但若对其了解不充分则不建议使用。
```
此种方式只生成一个String实例，而不是每次执行都创建新的实例。其可保证，对于所有在同一台虚拟机中运行的代码，只要它们包含相同的字符串字面量，该对象就会被重用。
- 对于同时提供了静态工厂方法和构造器的不可变类，通常可优先使用静态工厂方法而不是构造器，以避免合建不必要的对象。例如，静态工厂方法Boolean.valueOf(String)几乎总是优先于构造器new Boolean(String)。构造器在每次被调用时都会创建一个新的对象，而静态工厂方法则不要求这样做，实际也不会如此做。
- 除了重用不可变对象外，也可重用那些已知不会被修改的可变对象。即把已知不会被修改的局部变量必为final静态域，将其作为常量对象，代码更易于理解，且对于频繁调用性能可能会有显著提高（效果依赖于创建对象成本，即该对象创建代价，如Calendar对象相对创建代价较大--- 人个理解：如若涉及native调用应该代价会相对较高）
- 延迟初始化(lazily initializing)虽可消除这些不必要的初始化工作，但实际不建议，因延迟初始化会使方法的实现更加复杂，从而可能使得性能的提升效果打折扣。
- 如适配器模式，适配器是指这样一个对象：把功能委托给一个后备对象(backing object)，从而为后备对象提供一个可替代的接口。其无状态，无需合建多个适配器实例。（Adapter(适配器类):它可以调用另一个接口,作为一个转换器,对Adaptee和Target进行适配。它是适配器模式的核心。）
- 例如Map接口的keySet()方法返回